#!/usr/bin/env python

# DTF Core Content
# Copyright 2013-2016 Jake Valletta (@jake_valletta)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""Get information about binaries"""
import dtf.logging as log
from dtf.module import Module

import os.path

from elftools.common.exceptions import ELFError
from elftools.elf.dynamic import DynamicSection
from elftools.elf.elffile import ELFFile

TAG = 'bininfo'

class bininfo(Module):

    """Module class for viewing binary information"""

    about = 'Interact with system binaries.'
    author = 'Jake Valletta (jakev)'
    health = 'beta'
    name = 'bininfo'
    version = '1.0.0'

    def usage(self):

        """Print usage"""

        print "BinInfo dtf Module v%s" % self.version
        print ""
        print "Submodules:"
        print "    finddep   Find binaries using a libraries"
        print "    ldd       List dependent libraries."
        print ""

        return 0

    def cmd_ldd(self, args):

        """Get dependences of a binary"""

        if len(args) != 1:
            self.usage()

        elf_name = args.pop()

        if not os.path.isfile(elf_name):
            log.e(TAG, "File '%s' does not exist!" % elf_name)
            return -1

        with open(elf_name, 'rb') as elf_file:

            print "Shared libraries needed:"

            try:
                parsed_elf = ELFFile(elf_file)

                for section in parsed_elf.iter_sections():
                    if not isinstance(section, DynamicSection):
                        continue

                    for tag in section.iter_tags():
                        if tag.entry.d_tag == 'DT_NEEDED':
                            print '   %s' % tag.needed

            except ELFError as ex:
                log.e(TAG, "ELF error: %s" % ex)
                return -1

    # TODO
    def cmd_finddep(self, args):

        """Find binaries that depend on library"""

        pass

    def execute(self, args):

        """Main class executor"""

        if len(args) == 0:
            return self.usage()
        mode = args.pop(0)

        if mode == 'finddep':
            return self.cmd_finddep(args)
        elif mode == 'ldd':
            return self.cmd_ldd(args)
        else:
            return self.usage()
